using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace bagit_sharp
{
    public class Bag
    {
        //setting up private values
        private string pSource_Organization = "";
        private string pOrganization_Address = "";
        private string pContact_Name = "";
        private string pContact_Phone = "";
        private string pContact_Email = "";
        private string pExternal_Description = "";
        private string pExternal_Identifier = "";
        private string pBag_Size = "";
        private string pBag_Group_Identifier = "";
        private string pBag_Count = "";
        private string pBag_Software_Agent = "";
        private string pInternal_Sender_Identifier = "";
        private string pInternal_Sender_Description = "";
        private string pBagit_Profile_Identifier = "";
        private DateTime pBagging_Date = DateTime.Now;
        private string pPayload_Oxum = "";
        private System.Collections.Hashtable custom_headers = new System.Collections.Hashtable();
        private string pBag_Path = "";

        //specified encoding must be UTF8, no BOM
        private System.Text.Encoding default_encoding = new UTF8Encoding(false);
        private string pBag_Version = "0.97";
        private string pTag_File_Character_Encoding = "UTF-8";
        private string pErrorMessage = "";

        //Delegates
        public delegate void StatusMessage(object sender, string message);


        //enums
        public enum CHECKSUM_ALGOS { md5 = 0, sha1, sha256, sh384, sha512 };
        public enum ZIP_TYPES { zip = 0 };

        //Public Properties
        public string Source_Organization
        {
            get { return pSource_Organization; }
            set { pSource_Organization = value; }
        }

        public string Organization_Address
        {
            get { return pOrganization_Address; }
            set { pOrganization_Address = value; }
        }

        public string Contact_Name
        {
            get { return pContact_Name; }
            set { pContact_Name = value; }
        }

        public string Contact_Email
        {
            get { return pContact_Email; }
            set { pContact_Email = value; }
        }

        public string Contact_Phone
        {
            get { return pContact_Phone; }
            set { pContact_Phone = value; }
        }

        public string External_Description
        {
            get { return pExternal_Description; }
            set { pExternal_Description = value; }
        }

        public string External_Identifier
        {
            get { return pExternal_Identifier; }
            set { pExternal_Identifier = value; }
        }

        public long Bag_Size
        {
            get
            {
                try
                {
                    return (long)System.Convert.ToDouble(pBag_Size);
                }
                catch
                {
                    return -1;
                }
            }
            private set { pBag_Size = value.ToString(); }
        }

        /// <summary>
        /// Returns the internal value for bag size.  Use only 
        /// for debugging if the Bag_Size returns -1
        /// </summary>
        public string Bag_Size_Raw_Value
        {
            get { return pBag_Size; }
        }

        public string Bag_Group_Identifier
        {
            get { return pBag_Group_Identifier; }
            set { pBag_Group_Identifier = value; }
        }

        public int Bag_Count
        {
            get
            {
                try
                {
                    return System.Convert.ToInt32(pBag_Count);
                } catch {
                    return -1;
                }
            }
            private set { pBag_Count = value.ToString(); }
        }

        /// <summary>
        /// Returns Bag_Count Raw data.  Only use if Bag_Count returns
        /// -1
        /// </summary>
        public string Bag_Count_Raw_Value
        {
            get { return pBag_Count; }
        }

        public string Bag_Software_Agent
        {
            get { return pBag_Software_Agent; }
            set { pBag_Software_Agent = value; }
        }


        public string Internal_Sender_Identifier
        {
            get { return pInternal_Sender_Identifier; }
            set { pInternal_Sender_Identifier = value; }
        }

        public string Internal_Sender_Description
        {
            get { return pInternal_Sender_Description; }
            set { pInternal_Sender_Description = value; }
        }

        //autogenerated; return only
        public DateTime Bagging_Date
        {
            get { return pBagging_Date; }
            private set { pBagging_Date = value; }
        }

        //Autogenerated; return only
        public string Payload_Oxum
        {
            get { return pPayload_Oxum; }
            private set { pPayload_Oxum = value; }
        }

        public string Bag_Version
        {
            get { return pBag_Version; }
            set { pBag_Version = value; }
        }

        public string Tag_File_Character_Encoding
        {
            get { return pTag_File_Character_Encoding; }
            set {
                pTag_File_Character_Encoding = value;
                //this should also set default_encoding
                try
                {
                    System.Text.Encoding tenc = System.Text.Encoding.GetEncoding(value.ToLower());
                    default_encoding = tenc;
                } catch
                {
                    //keep default encoding as utf8
                }
            }
        }
        public string ErrorMessage
        {
            private set { pErrorMessage = value; }
            get { return pErrorMessage; }
        }

        public event StatusMessage UpdateStatus;
        public string Bag_Path
        {
            get { return pBag_Path; }
            set { pBag_Path = value; }
        }


        public Bag(string _inst_path = null)
        {
            if (_inst_path != null && System.IO.Directory.Exists(_inst_path))
            {
                Bag_Path = _inst_path;
                if (Bag_Path.EndsWith(System.IO.Path.DirectorySeparatorChar.ToString()) == false)
                {
                    Bag_Path += System.IO.Path.DirectorySeparatorChar.ToString();
                }
                load_bag_info(Bag_Path);
            } else if (_inst_path != null && !System.IO.Directory.Exists(_inst_path))
            {
                ErrorMessage = "specified bag path not located";
                EventPump(ErrorMessage);
                throw new BagException(ErrorMessage);
            }
        }

        private void load_bag_info(string s)
        {
            //need to implement
            //just load the bag info into the object
            if (System.IO.File.Exists(s + "bag-info.txt") == false)
            {
                ErrorMessage = "bag-info.txt not located.";
                EventPump(ErrorMessage);
                throw new BagException(ErrorMessage);
            }

            if (System.IO.File.Exists(s + "bagit.txt") == false)
            {
                ErrorMessage = "bagit.txt not located";
                EventPump(ErrorMessage);
                throw new BagException(ErrorMessage);
            }

            //first, let's load the bagit.txt file to find encoding
            //always utf8
            System.Collections.Hashtable taghash = read_tagged_file(s + "bagit.txt", new System.Text.UTF8Encoding(false));
            if (taghash.ContainsKey("bagit-version"))
            {
                Bag_Version = (string)taghash["bagit-version"];
            } else if (taghash.ContainsKey("tag-file-character-encoding"))
            {
                Tag_File_Character_Encoding = (string)taghash["tag-file-character-encoding"];
            }

            System.Collections.Hashtable headers = read_tagged_file(s + "bag-info.txt", default_encoding);
            SetBagProperties(headers);
        }

        private Hashtable read_tagged_file(string v, System.Text.Encoding enc)
        {
            string sline = "";
            System.Collections.Hashtable lhash = new Hashtable();
            System.IO.StreamReader reader = new System.IO.StreamReader(v, enc, false);
            while (reader.Peek() > -1)
            {
                sline = reader.ReadLine();
                if (sline.Trim().Length > 0)
                {
                    string[] parts = sline.Split(":".ToCharArray());
                    if (parts.Length == 2)
                    {
                        lhash.Add(parts[0].ToLower(), parts[1].Trim());
                    }
                }
            }
            reader.Close();
            return lhash;
        }


        #region "Property Bag"
        /// <summary>
        /// Private function to set bag properties.
        /// </summary>
        /// <param name="headers">[Optional HashTable]Following values are valid:
        /// Source-Organization
        /// Organization-Address
        /// Contact-Name
        /// Contact-Phone
        /// Contact-Email
        /// External-Description
        /// External-Identifier
        /// Bag-Group-Identifier
        /// Internal-Sender-Identifier
        /// Internal-Sender-Description
        /// BagIt-Profile-Identifier
        /// </param>
        public void SetBagProperties(System.Collections.Hashtable headers)
        {
            if (headers != null)
            {
                foreach (string key in headers.Keys)
                {
                    switch (key.ToLower())
                    {
                        case "source-organization":
                            Source_Organization = (string)headers[key];
                            break;
                        case "organization-address":
                            Organization_Address = (string)headers[key];
                            break;
                        case "contact-name":
                            Contact_Name = (string)headers[key];
                            break;
                        case "contact-email":
                            Contact_Email = (string)headers[key];
                            break;
                        case "contact-phone":
                            Contact_Phone = (string)headers[key];
                            break;
                        case "external-description":
                            External_Description = (string)headers[key];
                            break;
                        case "external-identifier":
                            External_Identifier = (string)headers[key];
                            break;
                        case "bag-group-identifier":
                            Bag_Group_Identifier = (string)headers[key];
                            break;
                        case "internal-sender-identifier":
                            Internal_Sender_Identifier = (string)headers[key];
                            break;
                        case "internal-sender-description":
                            Internal_Sender_Description = (string)headers[key];
                            break;
                        case "bagit-profile-identifier":
                            pBagit_Profile_Identifier = (string)headers[key];
                            break;
                        case "payload-oxum":
                            Payload_Oxum = (string)headers[key];
                            break;
                        default:
                            custom_headers.Add(key, (string)headers[key]);
                            break;
                    }
                }
            }
        }

        private System.Collections.Hashtable GetBagProperties()
        {
            System.Collections.Hashtable bhash = new System.Collections.Hashtable();
            bhash.Add("Source-Organization", Source_Organization);
            bhash.Add("Organization-Address", Organization_Address);
            bhash.Add("Contact-Name", Contact_Name);
            bhash.Add("Contact-Phone", Contact_Phone);
            bhash.Add("Contact-Email", Contact_Email);
            bhash.Add("External-Description", External_Description);
            bhash.Add("External-Identifier", External_Identifier);
            bhash.Add("Bagging-Date", DateTime.Now.ToString("yyyy-MM-dd"));
            bhash.Add("Bag-Size", FormatBytes(Bag_Size));
            bhash.Add("Payload-Oxum", Payload_Oxum);
            bhash.Add("Bag-Group-Identifier", Bag_Group_Identifier);
            bhash.Add("Bag-Count", Bag_Count.ToString());
            bhash.Add("Internal-Sender-Identifier", Internal_Sender_Identifier);
            bhash.Add("Internal-Sender-Description", Internal_Sender_Description);


            if (custom_headers != null && custom_headers.Count > 0)
            {
                foreach (string key in custom_headers.Keys)
                {
                    bhash.Add(key, (string)custom_headers[key]);
                }
            }

            return bhash;
        }

        #endregion

        internal void EventPump(string message)
        {
            System.Diagnostics.Debug.WriteLine(message);
            try
            {
                UpdateStatus(new Bag(), message);
            }
            catch { }
        }

        #region "Zip Bag/Unzip Bag"
        public bool ZipFile(string dir = "", string sdest ="", bool bGenerateChecksum = true)
        {
            string zip_file_name = "";
            if (dir.Trim().Length == 0)
            {
                dir = this.Bag_Path;
            }

            if (sdest.Trim().Length == 0)
            {
                //you have to remove the directory separator to get the 
                //parent directory for some reason
                sdest = System.IO.Directory.GetParent(dir.TrimEnd(new char[] { System.IO.Path.DirectorySeparatorChar })).FullName;
                
                if (sdest.EndsWith(System.IO.Path.DirectorySeparatorChar.ToString())==false) {
                    sdest += System.IO.Path.DirectorySeparatorChar.ToString();
                }
            }

            zip_file_name = sdest + new System.IO.DirectoryInfo(dir).Name + ".zip";
            
            try
            {
                ICSharpCode.SharpZipLib.Zip.FastZip fast = new ICSharpCode.SharpZipLib.Zip.FastZip();
                fast.CreateZip(zip_file_name, dir, true, null);

                if (bGenerateChecksum == true)
                {
                    //make a checksum
                    string zip_hash = CalcManifest(zip_file_name, CHECKSUM_ALGOS.md5);
                    System.IO.File.Create(sdest + zip_hash + ".md5").Close();
                    EventPump("zip file made");
                }
                return true;
            }
            catch (System.Exception ex)  {
                ErrorMessage = ex.ToString();
                EventPump(ErrorMessage);
                return false;
            }            
        }
        #endregion

        #region "Make Bag Function"
        /// <summary>
        /// Converts a given directory to a bag.  Bag information should be set either 
        /// when the class is created, or via the bag properties.
        /// </summary>
        /// <param name="bag_directory"></param>
        /// <param name="processes">At this point; isn't used</param>
        /// <param name="checksum"></param>
        /// <returns></returns>
        public Bag Make_Bag(string[] objects_to_bag,
            string bag_directory,
            System.Collections.Hashtable headers = null, 
            int processes = -1,
            CHECKSUM_ALGOS checksum = CHECKSUM_ALGOS.md5)
        {

            if (headers!=null && headers.Count > 0)
            {
                SetBagProperties(headers);
            }

            string file_not_found = "";
            if (ObjectsExist(ref objects_to_bag, out file_not_found) == false) {
                ErrorMessage = "Unabled to find object" + file_not_found;
                EventPump(ErrorMessage);
                return null;
            }
            

            EventPump("starting bagging process");
            EventPump("checksum algorthm used" + checksum.ToString());

            //create bag directory
            try
            {
                System.IO.DirectoryInfo dinfo = System.IO.Directory.CreateDirectory(bag_directory);
                bag_directory = dinfo.FullName;
            } catch
            {
                bag_directory = System.Environment.CurrentDirectory + System.IO.Path.DirectorySeparatorChar + bag_directory;
                System.IO.Directory.CreateDirectory(bag_directory);
            }
            
            if (bag_directory.EndsWith(System.IO.Path.DirectorySeparatorChar.ToString())==false)
            {
                bag_directory += System.IO.Path.DirectorySeparatorChar.ToString();
            }

            string data_directory = bag_directory + "data" + System.IO.Path.DirectorySeparatorChar.ToString();
            EventPump("bag is being created at: " + bag_directory);
            EventPump("creating payload data directory: " + data_directory);

            try
            {
                System.IO.Directory.CreateDirectory(data_directory);
            }
            catch
            {
                ErrorMessage = "Unable to create payload directory: " + data_directory;
                EventPump(ErrorMessage);
                return null;
            }

            bool bPreserveDir = false;

            if (objects_to_bag.Length > 1) { bPreserveDir = true; }



            foreach (string data_to_bag in objects_to_bag)
            {






                //make sure I can read and write to various locations
                string unreadable_dirs = "";
                string unreadable_files = "";


                //we stop if anything is unreadable
                if (CanRead(data_to_bag, ref unreadable_dirs, ref unreadable_files) == false)
                {
                    ErrorMessage = "Unable to read: " + data_to_bag;
                    EventPump(ErrorMessage);
                    //Remove the data_directory
                    try
                    {
                        System.IO.Directory.Delete(data_directory, true);
                    }
                    catch { }
                    return null;
                }
                else
                {
                    if (!String.IsNullOrEmpty(unreadable_dirs) || !string.IsNullOrEmpty(unreadable_files))
                    {
                        ErrorMessage = "Unreadble directories: " + unreadable_dirs + System.Environment.NewLine + "Unreadable files: " + unreadable_files;
                        EventPump(ErrorMessage);
                        //Remove the data_directory
                        try
                        {
                            System.IO.Directory.Delete(data_directory, true);
                        }
                        catch { }
                        return null;
                    }
                }

                //move files into the payload
                //track files that may have problems between
                //windows and unix based systems.

                try
                {
                    if (IsFile(data_to_bag))
                    {
                        try
                        {
                            System.IO.File.Copy(data_to_bag, data_directory + new System.IO.FileInfo(data_to_bag).Name, false);

                            try
                            {
                                //set file permissions
                                EventPump("mirroring file permissions for: " + data_to_bag);
                                System.Security.AccessControl.FileSecurity initial_file = System.IO.File.GetAccessControl(data_to_bag);
                                System.IO.File.SetAccessControl(data_directory + new System.IO.FileInfo(data_to_bag).Name, initial_file);
                            }
                            catch
                            {
                                ErrorMessage = "Unable to mirror permissions in the payload directory for the object: " + data_to_bag;
                                EventPump(ErrorMessage);
                            }
                        }
                        catch
                        {
                            ErrorMessage = "Unable to copy data: " + data_to_bag + ". Cleaning up temporary files";
                            EventPump(ErrorMessage);
                            try
                            {
                                System.IO.Directory.Delete(data_directory, true);
                            }
                            catch { }
                            return null;
                        }
                    }
                    else
                    {
                        //if (CopyFolder(data_to_bag, data_directory, false) == false)
                        string target_path = data_directory;
                        if (bPreserveDir == true)
                        {
                            target_path = data_directory + new System.IO.DirectoryInfo(data_to_bag).Name;
                            if (target_path.EndsWith(System.IO.Path.DirectorySeparatorChar.ToString()) == false)
                            {
                                target_path += System.IO.Path.DirectorySeparatorChar.ToString();
                            }
                            try
                            {
                                System.IO.Directory.CreateDirectory(target_path);
                            }
                            catch { }
                        }

                        EventPump("Copying to: " + target_path);

                        if (CopyFolder(new System.IO.DirectoryInfo(data_to_bag), new System.IO.DirectoryInfo(target_path)) == false)
                        {
                            ErrorMessage = "Unable to copy data to: " + target_path + "...cleaning up temporary files";
                            EventPump(ErrorMessage);
                            try
                            {
                                System.IO.Directory.Delete(data_directory, true);
                            }
                            catch { }
                            return null;
                        }

                        try
                        {
                            EventPump("mirroring directory permissions");
                            System.Security.AccessControl.DirectorySecurity initial_directory = System.IO.Directory.GetAccessControl(data_to_bag);
                            System.IO.Directory.SetAccessControl(data_directory, initial_directory);
                        }
                        catch
                        {
                            ErrorMessage = "Unable to mirror permissions in the payload directory for the object: " + data_to_bag;
                            EventPump(ErrorMessage);
                        }

                    }
                }
                catch
                {
                    ErrorMessage = "Unable to copy data: " + data_to_bag;
                    EventPump(ErrorMessage);
                    return null;
                }
            }
                    

            EventPump("writing the manifest file");
            long[] vals = make_manifest(bag_directory, checksum, "utf-8", true);

            
            Payload_Oxum = vals[0].ToString() + "." + vals[1].ToString();
            Bag_Size = vals[0];

            EventPump("write bag-info file");
            bool bret = make_bag_info(bag_directory);
            bret = make_bag_txt(bag_directory);

            bret = make_tagfile(bag_directory, checksum);
            
            EventPump("finished");
            return new Bag(bag_directory) ;
        }

        private bool ObjectsExist(ref string[] objects_to_bag, out string file_not_found)
        {
            string current_directory = System.Environment.CurrentDirectory;
            bool bResolved = false;
            file_not_found = string.Empty;
            if (current_directory.EndsWith(System.IO.Path.DirectorySeparatorChar.ToString())==false)
            {
                current_directory += System.IO.Path.DirectorySeparatorChar.ToString();
            }

            for (int x = 0; x<objects_to_bag.Length; x++) 
            {
                bResolved = false; //reset this on each loop
                string item = objects_to_bag[x];
                if (System.IO.File.Exists(item) == false)
                {
                    if (System.IO.File.Exists(current_directory + item))
                    {
                        item = current_directory + item;
                        objects_to_bag[x] = item;
                        bResolved = true;
                        return true;
                    }
                } else
                {
                    bResolved = true;
                    return true;
                }

                if (bResolved == false)
                {
                    if (System.IO.Directory.Exists(item) == false)
                    {
                        if (System.IO.Directory.Exists(current_directory + item))
                        {
                            //found
                            item = current_directory + item;
                            objects_to_bag[x] = item;
                            bResolved = true;
                            return true;
                        }
                    } else
                    {
                        bResolved = true;
                        return true;
                    }
                }

                if (bResolved == false)
                {
                    //cannot resolve the object, set the error and fail the 
                    //function
                    file_not_found = item;
                    return false;
                }                
            }

            return false;
        }
        #endregion


        #region "Validate Bag"
        public bool Validate_Bag(string _bag_path=null, bool bFast = true)
        {
            if (_bag_path == null)
            {
                if (System.IO.Directory.Exists(this.Bag_Path)==false)
                {
                    ErrorMessage = "bag path: " + Bag_Path + System.Environment.NewLine + "No Bag has been specified";
                    EventPump(ErrorMessage);
                    throw new BagException(ErrorMessage);
                } else
                {
                    _bag_path = this.Bag_Path;
                }
            } else
            {
                this.Bag_Path = _bag_path;
                load_bag_info(_bag_path);
            }

            validate_structure(_bag_path);
            validate_bagittxt(_bag_path);
            validate_tagfiles(_bag_path);
            validate_manifest_files(_bag_path);
            validate_contents(_bag_path, bFast);
            return true;
        }

        private void validate_structure(string bag_path)
        {
            if (System.IO.Directory.Exists(bag_path + "data")==false)
            {
                ErrorMessage = "Missing payload directory";
                EventPump(ErrorMessage);
                throw new BagException(ErrorMessage);
            }

            if (System.IO.File.Exists(bag_path + "bagit.txt") == false)
            {
                ErrorMessage = "Missing bagit.txt file";
                EventPump(ErrorMessage);
                throw new BagException(ErrorMessage);
                
            }

            bool manifest_found = false;
            

            foreach (string f in System.IO.Directory.GetFiles(bag_path))
            {
                if (System.IO.Path.GetFileName(f).StartsWith("manifest")==true)
                {
                    manifest_found = true;
                    break;
                }
            }

            if (manifest_found == false)
            {
                ErrorMessage = "Missing manifest file";
                EventPump(ErrorMessage);
                throw new BagException(ErrorMessage);
            }
        }
        private void validate_bagittxt(string bag_path)
        {
           System.IO.FileStream fs = new System.IO.FileStream(bag_path + "bagit.txt", System.IO.FileMode.Open);
            byte[] bits = new byte[3];
            fs.Read(bits, 0, 3);

            // UTF8 byte order mark is: 0xEF,0xBB,0xBF
            if (bits[0] == 0xEF && bits[1] == 0xBB && bits[2] == 0xBF)
            {
                fs.Close();
                ErrorMessage = "bagit.txt file must not contain BOM characters";
                EventPump(ErrorMessage);
                throw new BagException(ErrorMessage);
            }
            fs.Close();
        }
        private void validate_tagfiles(string bag_path)
        {
            foreach (string f in System.IO.Directory.GetFiles(bag_path))
            {
                if (System.IO.Path.GetFileName(f).StartsWith("tagmanifest"))
                {
                    validate_tagmanifest(f);
                }
            }
        }

        private void validate_tagmanifest(string tagmanifest)
        {
            CHECKSUM_ALGOS checksum = CHECKSUM_ALGOS.md5;

            //need to determine checksum
            if (tagmanifest.IndexOf("md5") > -1)
            {
                checksum = CHECKSUM_ALGOS.md5;
            } else if (tagmanifest.IndexOf("sha1")>-1)
            {
                checksum = CHECKSUM_ALGOS.sha1;
            } else if (tagmanifest.IndexOf("sha256") > -1)
            {
                checksum = CHECKSUM_ALGOS.sha256;
            } else if (tagmanifest.IndexOf("sha384") > -1)
            {
                checksum = CHECKSUM_ALGOS.sh384;
            }
            else if (tagmanifest.IndexOf("sha512") > -1)
            {
                checksum = CHECKSUM_ALGOS.sha512;
            }

            EventPump("CheckSum selected: " + checksum.ToString());
            string sline = "";
            string parent_directory = System.IO.Path.GetDirectoryName(tagmanifest);
            System.IO.StreamReader reader = new System.IO.StreamReader(tagmanifest, default_encoding, false);
            while (reader.Peek() > -1)
            {
                sline = reader.ReadLine();
                if (sline.Trim().Length > 0)
                {
                    sline = sline.Replace("\t", " ");
                    string[] parts = new string[2];
                    if (sline.IndexOf(" ")>-1)
                    {
                        parts[0] = sline.Substring(0, sline.IndexOf(" ")).Trim();
                        parts[1] = sline.Substring(sline.IndexOf(" ")).Trim();
                        if (parts[0] != CalcManifest(System.IO.Path.Combine(parent_directory, parts[1]), checksum))
                        {
                            ErrorMessage = "tagmanifest checksum doesn't match for: " + parts[1] + System.Environment.NewLine + 
                                "checksum: " + parts[0] + System.Environment.NewLine +
                                "using checksum: " + checksum.ToString() + System.Environment.NewLine + 
                                CalcManifest(System.IO.Path.Combine(parent_directory, parts[1]), checksum);
                            EventPump(ErrorMessage);
                            throw new BagException(ErrorMessage);
                        }
                    }
                }
            }
            reader.Close();
        }
        private void validate_manifest_files(string bag_path)
        {
            //this just checks to see if files are duplicate 
            //this would be a problem on windows
            System.Collections.ArrayList file_list = new System.Collections.ArrayList();
            foreach (string f in System.IO.Directory.GetFiles(bag_path))
            {
                if (System.IO.Path.GetFileName(f).StartsWith("manifest") == true)
                {
                    string[] manifest_lines = System.IO.File.ReadAllLines(f, default_encoding);
                    foreach (string mline in manifest_lines)
                    {
                        if (mline.Trim().Length > 0)
                        {
                            string tmp_mline = mline.TrimEnd();
                            if (tmp_mline.IndexOf("\t") > -1) { tmp_mline = tmp_mline.Replace("\t", " ");  }
                            string data_file = tmp_mline.Substring(tmp_mline.LastIndexOf(" ")).Trim();
                            if (file_list.IndexOf(data_file.ToLower()) > -1)
                            {
                                EventPump("Potential duplicate file located.  File: " + data_file.Trim() + System.Environment.NewLine +
                                    "On Windows, file names/paths are treated as case insensitive potentially " +
                                    "leading to data loss if not changed.");
                            }
                            else
                            {
                                file_list.Add(data_file.Trim().ToLower());
                            }
                        }
                    }
                    break;
                }
            }
        }

        private void validate_contents(string bag_path, bool bFast)
        {            
            //fast just checks the oxam
            //false looks at the whole file
            if (bFast == true)
            {
                //we are just going to check the oxam against all the data
                //in the payload
                if (string.IsNullOrEmpty(Payload_Oxum))
                {
                    ErrorMessage = "no oxum defined. cannot fast validate.";
                    EventPump(ErrorMessage);
                    throw new BagException(ErrorMessage);
                } else
                {
                    long fcount = 0;
                    long fsize = 0;
                    foreach (string f in System.IO.Directory.GetFiles(bag_path + "data", "*.*", System.IO.SearchOption.AllDirectories))
                    {
                        fcount++;
                        fsize += new System.IO.FileInfo(f).Length;
                        
                    }

                    string[] parts = Payload_Oxum.Split(".".ToCharArray());
                    if (parts[0] != fsize.ToString())
                    {
                        ErrorMessage = "contents do not appear to match based on the oxum evaluation";
                        EventPump(ErrorMessage);
                        throw new BagException(ErrorMessage);
                    }

                    if (parts[1] != fcount.ToString())
                    {
                        ErrorMessage = "file count doesn't match the oxum";
                        EventPump(ErrorMessage);
                        throw new BagException(ErrorMessage);
                    }
                }
            }
        }
        #endregion
        private bool make_bag_txt(string bag_directory)
        {
            
            
            System.IO.StreamWriter writer = new System.IO.StreamWriter(bag_directory + "bagit.txt", false, default_encoding);
            writer.Write("BagIt-version: " + Bag_Version + System.Environment.NewLine);
            writer.Write("Tag-File-Character-Encoding: " + default_encoding.WebName);
            writer.Close();

            return true;
        }
        private bool make_bag_info(string bag_directory)
        {
            System.Collections.Hashtable bag_info_hash = GetBagProperties();
            System.IO.StreamWriter writer = new System.IO.StreamWriter(bag_directory + "bag-info.txt", false, default_encoding);
            foreach (string key in bag_info_hash.Keys)
            {
                writer.Write(key + ": " + (string)bag_info_hash[key] + System.Environment.NewLine);
            }
            writer.Close();
            return true;
        }    
        private bool make_tagfile(string bag_directory, CHECKSUM_ALGOS checksum)
        {
            string tagmanifest_filename = "tagmanifest-" + alg(checksum) + ".txt";
            System.IO.StreamWriter writer = new System.IO.StreamWriter(bag_directory + tagmanifest_filename, false, default_encoding);
            foreach (string f in System.IO.Directory.GetFiles(bag_directory))
            {
                if (f.IndexOf("tagmanifest")==-1)
                {
                    if (System.IO.Path.GetFileNameWithoutExtension(f).StartsWith("manifest") && 
                        System.IO.Path.GetFileName(f) != "manifest-" + alg(checksum) + ".txt")
                    {
                        continue;
                    }
                    string sline = CalcManifest(f, checksum) + "\t" + System.IO.Path.GetFileName(f);

                }
            }
            writer.Close();
            return true;
        }
        private long[] make_manifest(string dir, CHECKSUM_ALGOS checksum, string encoding, bool bappend  = false)
        {
            string manifest_filename = "manifest-" + alg(checksum) + ".txt";
            

            long directorysize = 0;
            long number_of_files = 0;
            System.IO.StreamWriter writer = new System.IO.StreamWriter(dir + manifest_filename, bappend, default_encoding);
            foreach (string f in System.IO.Directory.GetFiles(dir + System.IO.Path.DirectorySeparatorChar.ToString() + "data", "*.*", System.IO.SearchOption.AllDirectories))
            {
                System.IO.FileInfo finfo = new System.IO.FileInfo(f);
                directorysize += finfo.Length;
                number_of_files++;
                EventPump("calculating checksum for " + f);
                string sline = CalcManifest(f, checksum) + "\t" + f.Substring(f.IndexOf("data")).Replace(System.IO.Path.DirectorySeparatorChar.ToString(), "/");
                if (string.IsNullOrEmpty(sline))
                {
                    ErrorMessage = "Unable to locate file: " + f;
                    EventPump(ErrorMessage);
                    throw new BagException(ErrorMessage);
                }
                writer.Write(sline + System.Environment.NewLine);
            }
            writer.Flush();
            writer.Close();

            return new long[] { directorysize, number_of_files };

        }

        private void BuildManifest(System.IO.StreamWriter writer, CHECKSUM_ALGOS checksum, string dir)
        {
            
            foreach (string f in System.IO.Directory.GetFiles(dir, "*.*", System.IO.SearchOption.AllDirectories))
            {
                string sline = CalcManifest(f, checksum) + "\t" + f.Substring(f.IndexOf("data") + 1).Replace(System.IO.Path.DirectorySeparatorChar.ToString(), "/");
                writer.Write(sline + System.Environment.NewLine);
            }
                
            //foreach (string d in System.IO.Directory.GetDirectories(dir))
            //{
            //    BuildManifest(writer, checksum, dir);
            //}

        }


        private string CalcManifest(string file, CHECKSUM_ALGOS checksum)
        {

            if (System.IO.File.Exists(file)==false)
            {
                if (file.IndexOf("*")>-1) { file = file.Replace("*", ""); }
                if (System.IO.File.Exists(file)==false) { return null; }
            }

            switch (checksum)
            {
                case CHECKSUM_ALGOS.md5:
                    {
                        using (var md5 = System.Security.Cryptography.MD5.Create())
                        {
                            using (var stream = System.IO.File.OpenRead(file))
                            {
                                return BitConverter.ToString(md5.ComputeHash(stream)).Replace("-", "").ToLower();
                            }
                        }
                    }
                    
                case CHECKSUM_ALGOS.sha1:
                    {
                        using (var sh1 = System.Security.Cryptography.SHA1.Create())
                        {
                            using (var stream = System.IO.File.OpenRead(file))
                            {
                                return BitConverter.ToString(sh1.ComputeHash(stream)).Replace("-", "").ToLower();
                            }
                        }
                    }
                    
                case CHECKSUM_ALGOS.sha256:
                    {
                        using (var sh256 = System.Security.Cryptography.SHA256.Create())
                        {
                            using (var stream = System.IO.File.OpenRead(file))
                            {
                                return BitConverter.ToString(sh256.ComputeHash(stream)).Replace("-", "").ToLower();
                            }
                        }
                    }
                    
                case CHECKSUM_ALGOS.sha512:
                    {
                        using (var sh512 = System.Security.Cryptography.SHA512.Create())
                        {
                            using (var stream = System.IO.File.OpenRead(file))
                            {
                                return BitConverter.ToString(sh512.ComputeHash(stream)).Replace("-", "").ToLower();
                            }
                        }
                    }
                    
                default:
                    {
                        using (var md5 = System.Security.Cryptography.MD5.Create())
                        {
                            using (var stream = System.IO.File.OpenRead(file))
                            {
                                return BitConverter.ToString(md5.ComputeHash(stream)).Replace("-", "").ToLower();
                            }
                        }
                    }
                    
            }
           

        }


        private bool CanRead(string dir, ref string unreadable_dirs, ref string unreadable_files)
        {
            
            try
            {
                if (IsFile(dir))
                {
                    try
                    {
                        System.IO.FileInfo finfo = new System.IO.FileInfo(dir);
                    }
                    catch
                    {
                        unreadable_files = dir;
                    }
                }
                else
                {
                    System.IO.DirectoryInfo dinfo = new System.IO.DirectoryInfo(dir);
                    foreach (string f in System.IO.Directory.GetFiles(dir))
                    {
                        try
                        {
                            System.IO.FileInfo finfo = new System.IO.FileInfo(f);
                        }
                        catch
                        {
                            unreadable_files += "|" + f;
                        }
                    }

                    foreach (string d in System.IO.Directory.GetDirectories(dir))
                    {
                        try
                        {
                            System.IO.DirectoryInfo d1info = new System.IO.DirectoryInfo(d);
                            CanRead(d, ref unreadable_dirs, ref unreadable_files);
                        }
                        catch
                        {
                            unreadable_dirs += "|" + d;
                        }
                    }
                }
            } catch
            {
                unreadable_dirs = dir;
                return false;
            }

            unreadable_dirs = unreadable_dirs.Trim("|".ToCharArray());
            unreadable_files = unreadable_files.Trim("|".ToCharArray());

            if (!string.IsNullOrEmpty(unreadable_files) || !string.IsNullOrEmpty(unreadable_dirs))
            {
                return false;
            }

            return true;
        }

        private bool IsFile(string dir)
        {
            if (System.IO.File.Exists(dir))
            {
                //its a file
                return true;
            } else
            {
                return false;
            }
        }

        private bool CopyFolder(System.IO.DirectoryInfo source, System.IO.DirectoryInfo target)
        {
            try
            {
                foreach (System.IO.DirectoryInfo dir in source.GetDirectories())
                    CopyFolder(dir, target.CreateSubdirectory(dir.Name));
                foreach (System.IO.FileInfo file in source.GetFiles())
                    file.CopyTo(System.IO.Path.Combine(target.FullName, file.Name), false);
            } catch (System.Exception e)
            {
                System.Windows.Forms.MessageBox.Show(e.ToString());
                System.Diagnostics.Debug.WriteLine(e.ToString());
                return false;
            }
            return true;
        }

        private string alg(CHECKSUM_ALGOS checksum)
        {
            switch (checksum)
            {
                case CHECKSUM_ALGOS.md5:
                    return "md5";                    
                case CHECKSUM_ALGOS.sha1:
                    return "sha1";                    
                case CHECKSUM_ALGOS.sha256:
                    return "sha256";
                case CHECKSUM_ALGOS.sh384:                    
                    return "sha384";           
                case CHECKSUM_ALGOS.sha512:
                    return "sh5a12";                    
                default:
                    return "md5";                    
            }
            
        }
        private string FormatBytes(long bytes)
        {
            string[] Suffix = { "B", "KB", "MB", "GB", "TB" };
            int i;
            double dblSByte = bytes;
            for (i = 0; i < Suffix.Length && bytes >= 1024; i++, bytes /= 1024)
            {
                dblSByte = bytes / 1024.0;
            }

            return String.Format("{0:0.##} {1}", dblSByte, Suffix[i]);
        }

        private void ThreadPoolCallback(Object threadContext)
        {
            int threadIndex = (int)threadContext;
            
        }
    }
}
